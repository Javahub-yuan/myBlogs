---
title:  Java基础（三） - 继承
tags:
  - Java
categories:
  - Java
comments: true
date: 2020-11-14 10:00:00


---

<img src="https://cdn.jsdelivr.net/gh/javahub-yuan/forBlogImages@master/img/20201114163115.png" style="zoom:63%;" />

<!--more-->

# Java基础（三） - 继承

## 1、继承

继承的基本思想就是：可以基于已有的类创建新的类。继承已存在的类就是复用（继承）这些类的方法，而且可以增加一些新的属性和方法，使新类能够适应新的情况。

Java中使用extends关键字表示继承，例如：`public class A extends B`，其中，B被称为超类、基类、父类，A被称为子类、派生类、孩子类。子类会自动继承父类的属性和方法，并且子类可以添加自己的一些属性方法，因此，子类会比超类拥有更多的功能。

## 2、方法覆盖和方法重载

**方法重载：Overload**
作用：解决了同一个类中，相同的功能方法名有不同的参数，既然是相同的功能，那么方法的名字就应该相同
规则：方法名相同，方法参数列表不同（参数类型、参数个数、参数顺序）

```java
//Overload
public void println(int i);
public void println(char c);
public void println(String s);
```

**方法覆盖：Override**
作用：覆盖只出现在类存在继承关系的时候，目的是解决子类继承父类之后，可能父类的某一个方法不满足子类的具体特征，此时需要重新在子类中定义该方法，并重写方法体。

规则：方法名、参数列表、返回值必须相同，访问修饰符相同或更宽，不能比父类中被覆盖方法抛出更多的异常

```java
//Override
//parent
public void println(int i);

//child
public void println(int i);
```

## 3、super关键字

覆盖方法中如果需要调用父类的属性方法，则需要使用super关键字，super关键字另一个作用就是调用父类的构造器，当调用父类构造器时，必须放置在子类构造器的第一句，如果子类没有显示调用父类构造器，则默认调用父类的无参构造器

```java
//调用父类的方法
super.getSalary();

//调用父类构造器，必须放置在子类构造器的第一条语句
public Manager(String name, double salary, int year) {
    super(name, year);
	this.bonus = salary;
}
```

## 4、多态

一个对象变量（引用）可以指示多种实际类型的现象成为**多态**，用通俗化讲就是：**父类类型引用指向子类类型对象**。多态存在的三个前提：

- 要有继承关系
- 子类重写了父类的方法
- 父类引用指向子类对象

在运行时虚拟机知道多态引用的实际对象类型，自动选择适当的方法，这称为**动态绑定**，多态也存在**弊端**：如果父类类型的引用指向子类对象，则这个引用不能使用子类特有的成员属性和方法，如果想要使用，则必须先进性类型强制转换

## 5、方法调用

弄清楚如何在对象上应用方法调用非常重要。比如下面假设要调用`x.f(args)`，隐式参数x声明为类C的一个对象。下面是调用过程的相信信息。

1. **虚拟机获取对象实际类型的方法表，可能是父类或所有子类的方法表。**

   编译器查看对象的声明类型和方法名，要注意的是，可能有多个名字为f的方法，但是它们的参数类型和返回名称不同。比如：f(int)和f(String)。编译器将会一一列举所有C类中名为f的方法和其超类中名为f且可以访问的方法（超类私有方法不可以访问）。

2. **虚拟机查找定义为`f()`签名的类，此时虚拟机已经知道应该调用哪个方法了**

   编译器查看调用方法时提供的参数类型，如果有名为f的方法中存在一个与所提供类型参数完全匹配，就使用该方法，这个过程被称为重载解析，不过允许参数类型转换，比如int可以转换为double等等。如果编译器没有找到与参数类型匹配的方法，或者发现经过类型转换后有多个方法与之匹配，就报错。至此，编译器已经知道需要调用的方法的名字和参数类型。

3. **虚拟机调用这个方法**

   如果是private、static或final方法，编译器可以准确地知道调用哪个方法，我们将这种方法调用称为静态绑定(static banding)。与之相对应的是，调用的方法依赖于隐式参数的实际类型，并且在运行时实现动态绑定。

   当程序运行时，并且采用动态绑定调用方法时，虚拟机一定调用与x引用对象实际类型最合适的那个类的方法，如果当前类中没有，还会在其父类中进行寻找。

> 因为每次调用方法都需要进行搜索，时间开销比较大。因此虚拟机预先为每个类创建了一个**方法表**，其中列出了所有方法的签名和实际调用的方法。
>
> 方法的名字和参数列表称为方法的**签名**

## 6、final关键字

- final修饰的变量称为常量，这些变量只能赋值一次
- final修饰的方法，不可以被覆盖（不可以重写），但可以继承使用
- final修饰类不可以被继承，目的是为了确保不会在子类中改变语义，如果一个类被声明为final类型，则只有其中的方法自动成为final类型，不包括字段

## 7、抽象类

## 8、访问修饰符

|         | 本类 | 同包 | 非同包子类 | 所有 |
| ------- | ---- | ---- | ---------- | ---- |
| public  | √    | √    | √          | √    |
| protect | √    | √    | √          | ×    |
| default | √    | √    | ×          | ×    |
| private | √    | ×    | ×          | ×    |

## 9、Object：所有类的超类

Object是所有类的父类，Java中的类可以不用明确指出，但是都扩展了Object。所以根据多态特性，可以使用Object类型的变量引用任何类型的对象（除了基本类型，因为基本类型不是对象）

3、泛型数组列表

4、对象包装器与自动装箱

5、参数数量可变的方法

6、枚举类

## 10、继承的设计技巧

1. 将公共操作和字段放在超类中
2. 不要使用受保护的字段
3. 使用继承实现"is-a"关系
4. 除非所有继承的方法都有意义，否则不要使用继承
5. 在覆盖方法时，不要改变预期行为
6. 使用多态，而不要使用类型信息
7. 不要滥用反射