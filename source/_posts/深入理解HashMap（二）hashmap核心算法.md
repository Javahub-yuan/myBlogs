---
title:  深入理解HashMap（二）hashmap核心算法
tags:
  - Java
  - JDK源码
  - HashMap
categories:
  - Java
comments: true
date: 2020-10-24 19:00:00
---

## 简介

在阅读HashMap源码时，在看到别人写的算法方法时刚开始有一种很难的感觉，但随着理解越来越深入，就会不断体会里面设计的巧妙，不断感慨自己仍需要不断进步

## hash算法

先看JDK 1.8 HashMap 的 hash 方法源码

```java
static final int hash(Object key) {
      int h;
      // key.hashCode()：返回散列值也就是hashcode
      // ^ ：按位异或
      // >>>:无符号右移，忽略符号位，空位都以0补齐
      return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
  }
```

### 原理解析

方法只有几行代码，不难理解要做什么事情：先计算出key的hashCode值，因为hash值是int类型，所以占4字节32位，取到低十六位，再与高十六位进行异或运

<!--more-->

算，最终取到的值就是hash方法最终结果。

但在刚开始看的时候不明白为什么要这样算，直接拿到hashCode值返回不就可以了吗？为什么还要再进行取低位异或运算？其实站在设计者的角度去想一想也可以大概理解，hash函数算法在HashMap中是一个很重要的算法，这样做是为了保证hash冲突尽可能的少，每个key算出来的hash值尽可能不一样。

HashMap中计算key在数组存放位置是`hash & (n - 1),n是数组的长度`，如果直接将算出hashCode值立即返回，因为`n - 1`一般不会很大，所以int的32位中高位一定是0，任何值&上0都为0，就导致hash的高位失去作用，只有几个低位在进行比较，这样hash冲突的概率就大大增加，显然并不符合hash算法的设计要求。所以，就有了上面所讲的两步，取到高16位，与低16位进行异或运算，这样就可以把高16位也派上用场，减少hash冲突的概率

### 使用实例讲解

[![BeSWCD.png](https://s1.ax1x.com/2020/10/24/BeSWCD.png)](https://imgchr.com/i/BeSWCD)

由上图可以发现，在计算下标时，只有hash值的低四位参与了下标的计算。key的hashcode与key右移16位进行异或得到的hash值，结合了前16位和后16位，所以相对来说是非常公平的。仅仅异或一下，既减少了系统的开销，也不会造成的因为高位没有参与下标的计算(table长度比较小时)，从而引起的碰撞。

## tableSizeFor()方法

第一次见tableSizeFor()方法着实给我惊呆了，还能这样写代码吗？一开始看的时候也是非常抗拒，不过学习之后就有种豁然开朗的感觉。

### 原理解析

tableSizeFor()方法是做什么用的呢？hashmap中有两个变量，分别为loadFactor、threshold，其中loadFactor的含义为负载因子，threshold的含义是阈值用于判断是否需要扩容，threshold = capacity * load factor，但是在初始化的时候，是使用tableSizeFor（）方法来初始化threshold,先看下源码

```java
static final int tableSizeFor(int cap) {
    int n = cap - 1;
    // >>> 为无符号右移
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}
```

因为数组中存放元素个数必须是2的整数次幂，所以返回值应该是大于等于输入cap值的最小2整数次幂。之所以要无符号右移五次，目的是为了使n的32位中，从最高位1开始，一直到最低位全部改为1；之所以在开头减一，结束时加一，目的是为了使算出的值为**大于等于**cap且为2的整数次幂。

### 实例讲解

看方法的时候不妨自己动手带入一个数值，手动debug看一下方法里面到底发生了什么，就会理解这个方法是做什么的？怎么实现的？

先来假设n的二进制为01xxx…xxx，

对n右移1位：001xx…xxx，再与01xxx…xxx位或得：011xx…xxx

对n右移2为：00011…xxx，再与011xx…xxx位或得：01111…xxx

对n右移4为：000001111…xxx，再与01111xx…xxx位或得：011111111…xxx

当右移8位时，我想应该都知道得到什么结果了吧，

综上可得，该算法让最高位的1后面的位全变为1。

最后再让结果n+1，即得到了2的整数次幂的值了。

现在回来看看第一条语句：

int n = cap - 1;

让cap-1再赋值给n的目的是另找到的目标值大于或等于原值。例如二进制1000，十进制数值为8。如果不对它减1而直接操作，将得到答案10000，即16。显然不是结果。减1后二进制为111，再进行操作则会得到原来的数值1000，即8。

语言描述的并不一定非常直观，需要自己去模拟一下程序运行过程，才能真正体会到设计的巧妙，而且每次读都会有新收获