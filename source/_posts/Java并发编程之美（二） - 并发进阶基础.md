---
title:  Java并发编程之美（二） - 并发进阶基础
tags:
  - 多线程并发
categories:
  - 多线程并发
comments: true
date: 2020-12-22 20:31:00






---

并发进阶基础

<!--more-->

# Java并发编程之美（二） - 并发进阶基础

## 1、什么是多线程并发编程？为什么要进行多线程并发编程？

一个CPU在某一时刻只能处理一个任务，在单核CPU时代，多任务都是并发执行的。当一个任务占用CPU运行时，其他任务会被挂起，当占用CPU的任务的时间片用完后，会把CPU让给其他任务使用，所以在单CPU时代多线程并没有太大意义，并且线程间频繁上下文切换还会带来额外开销。

在多核CPU时代，每个线程可以使用自己的CPU来并行运行，打破单核对多线程的限制，也减少线程上下文切换的开销。但是，多线程编程中，线程个数通常要比CPU个数多，所以一般也称为多线程并发编程，而不是并行编程。

## 2、Java中的线程安全问题

**线程安全问题：**多个线程同时读写一个共享资源，且没有采取任何同步措施，这就有可能会导致出现脏数据或这其他不可预见的结果。如果多个线程只是去读取共享资源，那也不会产生线程安全问题，只有当至少有一个线程修改共享资源时，才会存在线程安全问题。

**如何解决：**在线程访问共享变量时，采取适当同步操作，例如加锁，使用synchronized关键字进行同步

## 3、Java内存模型

Java内存模型规定，所有的变量都存放在主内存中，当线程使用共享变量时，会把主内存中的变量复制到自己的工作空间或叫做工作内存中，线程读写变量时，操作的都是自己工作内存中的变量，处理完成之后在将值更新会主内存。工作内存，在实际中对应的就是每个CPU独有的一级缓存或者所有CPU共享的二级缓存或者CPU的寄存器

## 4、Java中的共享变量内存可见性问题

**共享变量内存可见性问题：**主要是由线程工作内存导致的。两个线程分别使用不同CPU对一个共享变量进行操作，虽然看似操作的是同一个共享变量，但根据Java内存模型可以知道，实际操作的是自己线程中对应工作内存的变量，所以就可能会导致出现共享变量内存可见性问题。

例子：假设线程A和线程B同时操作一个共享变量，分别使用不同CPU执行，每个CPU都有自己独有的一级缓存和CPU之间共享的二级缓存

- 线程A首先获取共享变量X，由于两级缓存中都没有该变量，所以线程A直接从主内存中读取X=0，并缓存到两级缓存，之后就对X加一，处理完成之后再将X更新回两级缓存和主内存中。这时，两级缓存和主内存中的X都是1；
- 线程B也来对X进行操作，因为线程B所在CPU的一级缓存中没有变量X，所以就查看二级缓存，此时命中返回X=1，然后也对X进行加以操作，并更新回两级缓存和主内存中，此时，线程B所在的CPU两级缓存和主内存中X=2，一切正常；
- 线程A又需要对X进行加一操作，会首先去一级缓存中查找，命中后返回X=1，这里就出现了问题，在上一步中线程B已经将X修改为了2，但线程A获取变量X时仍获取的是1，这就是**内存不可见问题**。可以使用volatile关键字解决这个问题。

## 5、Java中的synchronized关键字

synchronized块是Java提供的一种原子性内置锁，Java中每个对象都可以把它当作一个同步锁来使用，synchronized关键字也可以被用来实现原子性操作。这些Java内置的、使用者看不到的锁被称为内部锁，也成为监视器锁。

线程在执行代码进行synchronized代码块2之前，会先自动获取内部锁（监视器锁，谁调用就获取谁的锁），这时候如果有其他线程想要执行该同步代码块时，就会被阻塞挂起。拿到内部锁的线程，只有在正常退出代码块、或抛出异常、或在同步代码块内调用wait系列方法时会释放该锁，因为该锁是排他锁，所以其他被阻塞的线程必须等待先拿到锁的线程释放后才可能获取到该锁。

**缺点：**当阻塞一个线程时，需要执行阻塞操作（从用户态切换到内核态来执行阻塞操作），这很耗费时间，另外，synchronized关键字会引起线程上下文切换，也会带来额外的开销

**synchronized内存语义：**可以解决共享变量内存可见性问题。当获取锁后，进入synchronized代码块时，会把代码块中将要用到的共享变量从线程的工作内存（即本地内存）中清除，使用这些变量时直接从主内存中加载；在释放锁时，会将工作内存（本地内存）中修改的共享变量刷新到主内存中，这样就解决了共享变量内存可见性问题。缺点：synchronized关键字会引起线程上下文切换并带来线程调度开销。

## 6、Java中的volatile关键字

volatile关键字也是Java为了解决共享变量内存可见性问题的一种解决方法，是一种比synchronized弱形式的同步。当一个变量被声明为volatile时，当线程写入volatile变量值就等价于退出synchronized代码块（把工作内存中的变量值同步到主内存中），读取volatile变量时等价于进入同步代码块（先清空工作内存中要用到的共享变量的值，再从主内存中获取最新值）。

**volatile与synchronized相同之处：**都可以解决共享变量内存可见性问题

**volatile与synchronized不同之处：**虽然都可以解决共享变量内存可见性问题，但是synchronized关键字是独占锁，同时只能有一个线程获取到内部锁，其他线程会被阻塞挂起，这就会存在线程上下文切换和线程重新调度的开销，这也是使用锁不好的地方；而volatile使用的是非阻塞算法，不会造成线程上下文切换开销，可以确保一个变量的更新对其他线程马上可见。

**<span name = "volatile">volatile关键字缺点：</span>**volatile只能保证共享变量的内存可见性，但是并不能保证操作的原子性。写入变量时如果依赖当前值，则需要读取-计算-写入三步操作，这三步操作不是原子性的，volatile不能保证原子性。它只能保证更新过的变量对其他线程立马可见，不会因为线程工作内存的缓存问题造成共享变量内存不可见。

**什么时候才使用volatile：**

1. 写入变量不依赖变量的当前值。主要是因为**[volatile关键字缺点](#volatile)**导致
2. 读写变量时没有加锁。加锁就已经保证了内存可见性，所以就不需要将变量声明为volatile的了

## 7、Java中的原子性操作

**原子性操作：**执行一系列操作时，要么全部执行，要么全部不执行，不存在只执行一部分的情况。例如，在设计计数器时，一般操作是先读取计数器的值，然后加一，再更新，如果这三步不是原子性操作，那就有可能会出现线程安全问题。

**`++i`并不是线程安全的：**因为不能保证它是原子性操作，将`++i`转换成汇编代码后，这一行代码就会被分解为四步操作，首先获取当前i值放入栈顶，再将1也放入栈顶，之后将栈顶中两个值相加并把结果放入栈顶，最后把栈顶的结果赋值给变量i。所以在Java中一行代码被转换为汇编后就不具有原子性了。

**解决`++i`线程不安全问题：**

1. 最简单的办法就是使用synchronized关键字进行同步，使用synchronized可以实现线程安全，主要保证了内存可见性和原子性，但缺点也比较明显，它是个独占锁，对于没有获取到内部锁的线程会被阻塞挂起，会增加线程上下文切换开销，并且虽然都方法并不会存在线程安全问题，但是为了保证变量的内存可见性，也需要在读方法上面也加上锁，同一时间只能有一个线程读取，大大降低了并发性。
2. 更好的办法是使用非阻塞CAS算法实现的原子性操作类，例如AtomicLong

## 8、Java中的CAS操作

**出现背景？解决什么问题？：**synchronized和volatile两个关键字都有一定缺点，前者是独占锁，没有获取到锁的线程会被阻塞挂起，会导致线程上下文切换和重新调度开销；后者虽然是非阻塞的，但只能保证共享变量的内存可见性，不能解决读-改-写操作的原子性。

因此，出现了CAS操作(Compare and Swap)，非阻塞原子性操作，在更新之前先会比较值和期望的是否一致，如果一致就更新，否则就不更新，通过硬件保证了比较更新的原子性。JDK中Unsafe类提供了一系列的CAS方法。

**ABA问题：**假设变量X的值为A，现在线程1想要通过CAS操作，将变量X的值修改为B，就有可能会出现这种情况，在线程1获取到变量X的值为A后，在执行CAS之前，线程2先使用CAS操作将变量X修改为了B，然后又使用CAS操作将变量修改为了A，这时候线程再去进行CAS操作也会成功，但是线程1在进行CAS操作时看到的变量X虽然还是A，但这个A已经不是线程1最开始获取到的A了。

**为什么会产生？怎么解决：**产生原因是因为变量的状态值产生环形转换，就是变量可以从A变为B，在可以从B变为A。如果变量值不会产生环形转换，即只能朝一个方向转换，就不会存在问题。JDK中AtomicStampedReference类给每个变量的状态值都配备了一个时间戳，这样就不会有ABA问题了

## 9、Unsafe类

## 10、Java指令重排序

**什么时指令重排序：**为了提高性能，对于那些没有相互数据依赖的指令，编译器可能会对这些指令进行重排序，以提高运行性能。没有相互数据依赖是指这两条指令之间并没有相互依赖，例如，程序中有三条指令，第一条是定义一个变量a等于1，第二条指令是定义一个变量b等于2，第三条是定义一个变量c等于a+b，因为第三条指令依赖前两条指令，所以是有依赖关系的，所以重排序后能够保证第三条指令执行位于前两条之后，但前两条指令谁先执行就不一定了。

**重排序存在的问题：**单线程下并不会存在问题，可以保证重排序后执行最终结果，和顺序执行的结果是一致的。但在多线程下可能就会存在问题...

**解决办法：**使用volatile关键字。当volatile修饰一个变量，在写变量时，可以确保写之前的操作不会被重排序到写之后；在读变量时，可以确保都之后的操作不会被重排序到都之前

## 11、伪共享

**为什么需要CPU缓存？：**虽然内存速度要比硬盘快很多，但CPU的运行速度更快，为了解决CPU与主内存之间速度差问题，会在CPU和主内存之间添加一级或多级缓存，假如有两级缓存，那么一级缓存是每个CPU私有的，二级缓存是所有CPU共享的。在缓存内部是按照行来存储的，每一行成为一个缓存行，缓存行也是缓存和主内存进行数据交换的基本单位，大小一般为2的整数次幂字节。

**如何缓存：**当CPU要访问某个变量时，会首先查看在缓存中是否存在，如果存在则取出，没有则去主内存中查找，并且会把该变量附近，大小为一个缓存行的内存块数据，复制到缓存中。因为复制的是否并不是单单只复制一个变量，而是一个缓存块大小的内存块，在这个内存块中可能有多个变量，所以一个缓存行中就可能会有多个变量。

**什么是伪共享：**根据CPU缓存特性，一个缓存行中可能会有多个变量，由于同时只能有一个线程操作缓存行，相比将每个变量放到一个缓存行，性能会有所下降，这就是伪共享。例子：假如CPU1和CPU2的一级缓存的某个缓存行都保存有变量x，y，如果线程1对CPU1中的变量x进行更新，会首先修改CPU1中的一级缓存中变量x，根据缓存一致性原则，CPU2中的变量x对应的缓存行失效，这时如果线程2修改CPU2中变量x对应缓存行中的变量，则只能去二级缓存中去查找，导致性能会有所下降，如果CPU只有一级缓存，则会导致频繁的访问主内存。

**为什么会出现伪共享：**产生的原因是因为多个变量被放入一个缓存行中，并且多个线程同时去写入缓存行中不同的变量。

**如何避免伪共享：**

1. JDK8之前，一般时通过字节填充的方式来避免伪共享的。例如，创建一个变量时，使用填充字段填充该字段所在的缓存行，这样就可以避免多个变量放入同一个缓存行中。
2. JDK8提供了`sun.misc.Contended`注解，用来解决伪共享问题。这个注解可以修饰类，也可以修饰属性，但在默认情况下，只能修饰Java核心类，比如rt包下面的类。如果用户路径下的类需要使用这个注解，则需要添加JVM参数`-XX:RestrictContended`，填充的宽度默认为128，可以通过`-XX:ContendedPaddingWidth`参数自定义宽度

## 12、锁的概述

1. ### 乐观锁与悲观锁

   **悲观锁：**是指对数据被外界修改持保守态度，认为数据很容易就被其他线程修改，所以在对数据处理之前，需要对数据加锁，并在整个处理过程中，数据都处于锁定状态。加的锁通常是排他锁，同一时间只能有一个线程获取到锁，如果获取锁失败，则说明其他线程正在修改数据，当前线程可以等待或抛出异常；如果获取锁成功，则修改数据，然后提交事务释放排他锁。

   **乐观锁：**与悲观锁相反，认为数据一般不容易会被其他线程修改，持乐观态度，所以在操作数据时不会加排他锁，一般在表中添加version字段，在数据提交更新时，才会进行检测，检测数据是否被其他线程修改过了。因为乐观锁知道提交时才会锁定，所以不会产生任何死锁。

2. ### 公平锁与非公平锁

   线程获取锁的抢占机制

   **公平锁：**线程获取锁的顺序，是按照线程请求锁的时间早晚决定的。即最早请求锁的线程，将最早获取到锁，先到先得。

   **非公平锁：**运行时闯入，即先到不一定先得。在没有特殊需求的前提下，尽量使用非公平锁，因为公平锁会带来性能开销。

3. ### 独占锁与共享锁

   根据锁是只能被单个线程持有，还是能够被多个线程共同持有来划分

   **独占锁：**任何时候只能有一个线程获取到该锁，例如`ReentrantLock`就是独占锁。独占锁是一种悲观锁，会降低了并发性，因为读操作并不会影响数据一致性，但独占锁只允许同一时刻只能有一个线程读

   **共享锁：**可以同时被多个线程持有，例如`ReadWriteLock`读写锁，它允许多个线程同时进行读操作。共享锁是一种乐观锁，放宽了加锁条件，允许多个线程同时进行读操作。

4. ### 可重入锁

   **可重入锁：**只要该线程获取了该锁，那么就可以再次进入该被锁住的代码。当一个线程获取到独占锁后，如果其他线程来获取该独占锁，则会被阻塞挂起，但如果是获取了该锁的线程再次获取锁时，发现锁拥有者是自己，则可再次进入该线程。synchronized是可重入锁，内部维护了一个标识和计数器，分别用来表示是哪个线程获取到了锁，以及获取次数。

5. ### 自旋锁

   **自旋锁：**当一个线程获取锁时，如果获取失败，并不是马上阻塞挂起，而是在不放弃CPU使用权的情况下，多次尝试去获取锁，很有可能会在后面多次尝试中就获取到了锁。这是一种用CPU时间换取线程阻塞调度开销，但线程在后面多次尝试过程中也有可能获取不到锁浪费CPU时间。

   **为什么出现自旋锁：**Java中线程是与操作系统中的线程一一对应，所以当一个线程在获取锁失败后，会被切换到内核状态而被阻塞挂起。当该线程获取到锁时，又需要将其切换到内核状态而唤醒线程，而从用户状态切换到内核状态开销很大，在一定程度上影响并发性能。

   > 什么是内核状态？用户状态？







