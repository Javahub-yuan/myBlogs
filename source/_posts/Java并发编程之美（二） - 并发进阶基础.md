---
title:  Java并发编程之美（二） - 并发进阶基础
tags:
  - 并发
categories:
  - 并发
comments: true
date: 2020-12-22 20:31:00






---

并发进阶基础

<!--more-->

# Java并发编程之美（二） - 并发进阶基础

## 1、什么是多线程并发编程？为什么要进行多线程并发编程？

一个CPU在某一时刻只能处理一个任务，在单核CPU时代，多任务都是并发执行的。当一个任务占用CPU运行时，其他任务会被挂起，当占用CPU的任务的时间片用完后，会把CPU让给其他任务使用，所以在单CPU时代多线程并没有太大意义，并且线程间频繁上下文切换还会带来额外开销。

在多核CPU时代，每个线程可以使用自己的CPU来并行运行，打破单核对多线程的限制，也减少线程上下文切换的开销。但是，多线程编程中，线程个数通常要比CPU个数多，所以一般也称为多线程并发编程，而不是并行编程。

## 2、Java中的线程安全问题

**线程安全问题：**多个线程同时读写一个共享资源，且没有采取任何同步措施，这就有可能会导致出现脏数据或这其他不可预见的结果。如果多个线程只是去读取共享资源，那也不会产生线程安全问题，只有当至少有一个线程修改共享资源时，才会存在线程安全问题。

**如何解决：**在线程访问共享变量时，采取适当同步操作，例如加锁，使用synchronized关键字进行同步

## 3、Java内存模型

Java内存模型规定，所有的变量都存放在主内存中，当线程使用共享变量时，会把主内存中的变量复制到自己的工作空间或叫做工作内存中，线程读写变量时，操作的都是自己工作内存中的变量，处理完成之后在将值更新会主内存。工作内存，在实际中对应的就是每个CPU独有的一级缓存或者所有CPU共享的二级缓存或者CPU的寄存器

## 4、Java中的共享变量内存可见性问题

**共享变量内存可见性问题：**主要是由线程工作内存导致的。两个线程分别使用不同CPU对一个共享变量进行操作，虽然看似操作的是同一个共享变量，但根据Java内存模型可以知道，实际操作的是自己线程中对应工作内存的变量，所以就可能会导致出现共享变量内存可见性问题。

例子：假设线程A和线程B同时操作一个共享变量，分别使用不同CPU执行，每个CPU都有自己独有的一级缓存和CPU之间共享的二级缓存

- 线程A首先获取共享变量X，由于两级缓存中都没有该变量，所以线程A直接从主内存中读取X=0，并缓存到两级缓存，之后就对X加一，处理完成之后再将X更新回两级缓存和主内存中。这时，两级缓存和主内存中的X都是1；
- 线程B也来对X进行操作，因为线程B所在CPU的一级缓存中没有变量X，所以就查看二级缓存，此时命中返回X=1，然后也对X进行加以操作，并更新回两级缓存和主内存中，此时，线程B所在的CPU两级缓存和主内存中X=2，一切正常；
- 线程A又需要对X进行加一操作，会首先去一级缓存中查找，命中后返回X=1，这里就出现了问题，在上一步中线程B已经将X修改为了2，但线程A获取变量X时仍获取的是1，这就是**内存不可见问题**。可以使用volatile关键字解决这个问题。

## 5、Java中的synchronized关键字

synchronized块是Java提供的一种原子性内置锁，Java中每个对象都可以把它当作一个同步锁来使用，synchronized关键字也可以被用来实现原子性操作。这些Java内置的、使用者看不到的锁被称为内部锁，也成为监视器锁。

线程在执行代码进行synchronized代码块2之前，会先自动获取内部锁（监视器锁，谁调用就获取谁的锁），这时候如果有其他线程想要执行该同步代码块时，就会被阻塞挂起。拿到内部锁的线程，只有在正常退出代码块、或抛出异常、或在同步代码块内调用wait系列方法时会释放该锁，因为该锁是排他锁，所以其他被阻塞的线程必须等待先拿到锁的线程释放后才可能获取到该锁。

**缺点：**当阻塞一个线程时，需要执行阻塞操作（从用户态切换到内核态来执行阻塞操作），这很耗费时间，另外，synchronized关键字会引起线程上下文切换，也会带来额外的开销

**synchronized内存语义：**可以解决共享变量内存可见性问题。当获取锁后，进入synchronized代码块时，会把代码块中将要用到的共享变量从线程的工作内存（即本地内存）中清除，使用这些变量时直接从主内存中加载；在释放锁时，会将工作内存（本地内存）中修改的共享变量刷新到主内存中，这样就解决了共享变量内存可见性问题。缺点：synchronized关键字会引起线程上下文切换并带来线程调度开销。

## 6、Java中的volatile关键字

volatile关键字也是Java为了解决共享变量内存可见性问题的一种解决方法，是一种比synchronized弱形式的同步。当一个变量被声明为volatile时，当线程写入volatile变量值就等价于退出synchronized代码块（把工作内存中的变量值同步到主内存中），读取volatile变量时等价于进入同步代码块（先清空工作内存中要用到的共享变量的值，再从主内存中获取最新值）。

**volatile与synchronized相同之处：**都可以解决共享变量内存可见性问题

**volatile与synchronized不同之处：**虽然都可以解决共享变量内存可见性问题，但是synchronized关键字是独占锁，同时只能有一个线程获取到内部锁，其他线程会被阻塞挂起，这就会存在线程上下文切换和线程重新调度的开销，这也是使用锁不好的地方；而volatile使用的是非阻塞算法，不会造成线程上下文切换开销，可以确保一个变量的更新对其他线程马上可见。

**<span name = "volatile">volatile关键字缺点：</span>**volatile只能保证共享变量的内存可见性，但是并不能保证操作的原子性。写入变量时如果依赖当前值，则需要读取-计算-写入三步操作，这三步操作不是原子性的，volatile不能保证原子性。它只能保证更新过的变量对其他线程立马可见，不会因为线程工作内存的缓存问题造成共享变量内存不可见。

**什么时候才使用volatile：**

1. 写入变量不依赖变量的当前值。主要是因为**[volatile关键字缺点](#volatile)**导致
2. 读写变量时没有加锁。加锁就已经保证了内存可见性，所以就不需要将变量声明为volatile的了

## 7、Java中的原子性操作

**原子性操作：**执行一系列操作时，要么全部执行，要么全部不执行，不存在只执行一部分的情况。例如，在设计计数器时，一般操作是先读取计数器的值，然后加一，再更新，如果这三步不是原子性操作，那就有可能会出现线程安全问题。

**`++i`并不是线程安全的：**因为不能保证它是原子性操作，将`++i`转换成汇编代码后，这一行代码就会被分解为四步操作，首先获取当前i值放入栈顶，再将1也放入栈顶，之后将栈顶中两个值相加并把结果放入栈顶，最后把栈顶的结果赋值给变量i。所以在Java中一行代码被转换为汇编后就不具有原子性了。

**解决`++i`线程不安全问题：**

1. 最简单的办法就是使用synchronized关键字进行同步，使用synchronized可以实现线程安全，主要保证了内存可见性和原子性，但缺点也比较明显，它是个独占锁，对于没有获取到内部锁的线程会被阻塞挂起，会增加线程上下文切换开销，并且虽然都方法并不会存在线程安全问题，但是为了保证变量的内存可见性，也需要在读方法上面也加上锁，同一时间只能有一个线程读取，大大降低了并发性。
2. 更好的办法是使用非阻塞CAS算法实现的原子性操作类，例如AtomicLong

## 8、Java中的CAS操作

**出现背景？解决什么问题？：**synchronized和volatile两个关键字都有一定缺点，前者是独占锁，没有获取到锁的线程会被阻塞挂起，会导致线程上下文切换和重新调度开销；后者虽然是非阻塞的，但只能保证共享变量的内存可见性，不能解决读-改-写操作的原子性。

因此，出现了CAS操作(Compare and Swap)，非阻塞原子性操作，在更新之前先会比较值和期望的是否一致，如果一致就更新，否则就不更新，通过硬件保证了比较更新的原子性。JDK中Unsafe类提供了一系列的CAS方法。

**ABA问题：**假设变量X的值为A，现在线程1想要通过CAS操作，将变量X的值修改为B，就有可能会出现这种情况，在线程1获取到变量X的值为A后，在执行CAS之前，线程2先使用CAS操作将变量X修改为了B，然后又使用CAS操作将变量修改为了A，这时候线程再去进行CAS操作也会成功，但是线程1在进行CAS操作时看到的变量X虽然还是A，但这个A已经不是线程1最开始获取到的A了。

**为什么会产生？怎么解决：**产生原因是因为变量的状态值产生环形转换，就是变量可以从A变为B，在可以从B变为A。如果变量值不会产生环形转换，即只能朝一个方向转换，就不会存在问题。JDK中AtomicStampedReference类给每个变量的状态值都配备了一个时间戳，这样就不会有ABA问题了

## 9、Unsafe类

## 10、Java指令重排序

## 11、伪共享

## 12、锁的概述

