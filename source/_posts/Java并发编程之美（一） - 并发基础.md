---
title:  Java并发编程之美（一） - 并发基础
tags:
  - 多线程并发
categories:
  - 多线程并发
comments: true
date: 2020-12-22 20:30:00



---



总结学习多线程基础知识，持续更新

<!--more-->

# Java并发编程之美（一） - 并发基础

## 1.1什么是进程、线程

**进程**是代码在数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位。讲人话就是：在电脑上每打开运行一个软件就是一个进程，在Java中，当启动main函数时就是启动了一个进程，而main函数所在的线程就是这个进程中的一个线程，也成为主线程。

**线程**是进程中的一个实体，线程本身不会独立存在，一个进程中至少包含一个线程。

**进程与线程的关系**：一个进程中至少包含一个线程。操作系统在分配资源的时候是把资源分配给了进程，但是CPU资源比较特殊，它是被分配给进程的，因为真正占用CPU运行的线程，所以也说线程是CPU分配的基本单位。

**与内存之间的关系**：一个进程中有多个线程，多个线程共享进程的堆和方法区资源（共享），但是每个资源都有自己的程序计数器和栈区域（非共享）

- 程序计数器：用来记录线程当前要执行指令的地址。记录线程在CPU时间片用完后，让出CPU时执行指令的地址，等到下次再分配到时间片时就可以从自己的程序计数器里面读取该要执行的指令地址，继续执行。（如果执行的是native方法，那么pc计数器记录的是undefined地址，只有执行的是Java代码时，pc计数器记录的才是下一条指令的地址）
- 栈：用来存储局部变量（还有其他功能，不详细说明）。这些局部变量是线程私有的，其他线程访问不了。
- 堆：是一个进程中最大的一块内存，主要存放创建的实例对象，是共享的。
- 方法区：存放JVM加载的类、常量以及静态变量等信息，是共享的。

## 1.2线程的创建与运行

Java线程有三种创建方式：

- 实现Runnable接口的run方法
- 继承Thread类并重写run方法
- 使用FutureTask方式

**1.2.1 实现Runnable接口的run方法**

好处：

1. 实现Runnable接口，还可以继承其他类
2. 多个线程可以公用一个任务代码逻辑，即一个任务可以创建多次

缺点：

1. 没有返回值

**1.2.2 继承Thread类并重写run方法**

使用时，先创建线程实例，再调用start()方法才启动线程。但调用完start()方法后并不一定会立即执行，而是处于就绪状态，此时该线程除了没有获取CPU资源外，已经获取好其他资源，等待到获取CPU资源后才真正处于运行状态，run方法执行完毕该线程就处于终止状态。

好处：

1. 在run方法内部获取当前线程直接使用this就可以了，不需要使用`Thread.currentThread()`方法

缺点：

1. Java不支持多继承，继承了Thread，就不能继承其他类了

 	2. 线程和任务没有分离，如果多个线程执行一样的任务，就需要多份任务代码，而Runnable没有这个限制
      	3. 没有返回值

**1.2.3 使用FutureTask方式**

实现了Callable接口的call()方法。在main函数内创建了一个FutureTask对象，相当于异步任务，之后创建一个线程并启动它，最后通过futureTask.get()方法等待任务执行完毕，并返回结果

## 1.3线程通知与等待

**wait()函数：**当一个线程调用一个共享变量的wait()方法时，该调用线程会被阻塞挂起，需要注意，调用该方法之前需要获取该对象的监视器锁(可以通过synchronized关键字获取锁)否则会抛出异常。

当前线程调用共享变量的wait()方法，只会释放当前共享变量上的锁，如果当前线程还持有其他共享变量的锁，则这些锁是不会被释放的（哪个共享变量调用wait()方法，就会释放哪个共享变量的监视器锁，然后将该线程阻塞挂起，并不会释放该线程上已经获取到的其他共享变量的锁）

直到发生下面几件事之一才会返回：

- 其他线程调用了该共享对象的notify()或者notifyAll()方法；
- 其他线程调用了该线程的interrupt()方法，该线程抛出异常而返回（当一个线程调用共享变量的wait()方法后被阻塞挂起，如果其他线程中断了该线程，则该线程会抛出`InterruptedException`异常并返回）

**虚假唤醒：**即使没有发生上面两种情况，线程也可能会被唤醒，这就是虚假唤醒。为了避免虚假唤醒产生影响，做法就是使用while循环，不停的去测试该线程被唤醒的条件是否满足，如果不满足则继续阻塞挂起等待

```java
synchronized(obj) {
    while(条件不满足) {
        obj.wait();
    }
}
```



**wait(long timeout)函数：**与wait()方法的区别就是，如果一个线程调用了共享变量的该方法后，如果没有在指定的（毫秒）时间被其他线程调用该共享变量的notify()或notifyAll()方法唤醒，那么该函数还是会因为超时而返回。wait()方法内部就是调用该方法，参数传的是0，即wait(0)。

**wait(long timeout, int nanos)函数：**内部调用wait(long timeout)函数，只有nanos大于0时，才使参数timeout递增1。

**notify()函数：**一个线程调用共享对象的notify()方法后，会唤醒一个因调用该共享变量的wait()系列方法而挂起的线程，如果有多个被挂起的线程，则随机唤醒一个。注意，被唤醒的线程并不能马上从wait()方法返回并继续执行，它必须和其他线程一起竞争该共享变量的锁，只有竞争到该共享变量的监视器锁参可以继续执行。调用该方法时，和wait()方法类似，也必须先获取到共享变量的监视器锁，否则会抛出异常

**notifyAll()函数：**一个线程调用共享变量的notifyAll()方法后，会唤醒所有因调用该共享变量的wait()系列方法而被挂起的线程。注意，该方法只会释放调用notifyAll()之前，调用wait()系列方法被阻塞的线程，而不会释放调用完该方法之后被阻塞挂起的线程

## 1.4等待线程执行终止的join方法

例如主线程调用了threadOne.join()方法，那么主线程会被阻塞，等待threadOne线程执行完毕返回，主线程才会继续往下执行，如果主线程在被阻塞过程中，其他线程调用了主线程的iterrupt()方法，则被阻塞的主线程就会抛出异常。

使用场景：需要等待某几件事情完成后才能继续往下执行，例如在线程加载资源时，需要等待多个线程全部加载完毕再汇总处理。也可以使用countDownLatch

## 1.5让线程睡眠的sleep方法

该方法是Thread类的一个静态方法。当一个线程调用sleep方法后，调用线程会暂时让出指定时间的执行权，也就是在这段期间不参与CPU调度，但是该线程所拥有的监视器资源，比如锁还是持有不会释放。指定时间到后会正常返回，该线程处于就绪状态，然后参与CPU的调度，获取到CPU资源后就可以正常运行了。

如果在睡眠期间其他线程调用了该线程的interrupt方法中断了该线程，则会抛出异常而返回。

## 1.6让出CPU执行权的yield方法

该方法时Thread类的一个静态方法。操作系统为每个线程分配一个时间片来占有CPU，正常情况下当一个线程把分配给自己的时间片使用完后，线程调度器才会进行下一轮的线程调度。而当一个线程调用了yield方法时，是在告诉线程调度器自己的时间片还没有使用完但剩余部分自己不想使用了，这就暗示线程调度器现在就可以进行下一轮的线程调用，该线程会让出CPU使用权并处于就绪状态，之后，线程调度器会从线程就绪队列中选取一个优先级最高的线程，当然也有可能回调度到刚刚调用yield方法的线程

**sleep和yield方法的区别：**当线程调用sleep方法时，该线程会被阻塞挂起指定时间，在这段时间调度器不会去调度该线程。而调用yield方法时，线程只是让出自己剩余时间片，并没有被阻塞挂起，而是处于就绪状态，线程调度器进行下一次调度时还有可能会调度到当前线程。

## 1.7线程中断

Java中线程中断是一种线程间的协作模式，通过设置线程的中断标志，并不能直接终止线程的执行，而是需要根据中断状态自行处理。

- **void interrupt()方法：**中断线程，设置标志位。例如：线程A运行时，线程B可以调用线程A的interrupt()方法设置线程A的中断标志为true并立即返回，仅仅是设置中断标志位，xianchengA实际并没有被中断，会继续往下执行。且如果线程A因为调用wait()系列函数、join方法或sleep方法而被阻塞挂起，这时候线程A会在调用这些方法的地方抛出InterruptException异常而返回。

- **boolean isInterrupted()方法：**检测当前线程是否被中断，如果是则则返回true，否则返回false；

- **boolean interrupted()方法：**检测当前线程是否被中断，如果是则返回true，否则返回false。与isInterrupted()方法不同的是，该方法如果发现当前线程被中断，则会清除中断标志，并且该方法是static方法，可以通过Thread类直接调用。

  >  注意：`在interrupt()内部获取的是当前调用线程的中断标志，而不是调用interrupt()方法的实例对象的中断标志`，意思是，如果在主线程中调用threadOne.interrupted()方法，则返回的是调用线程的中断标志，即主线程的中断标志，而不是实例对象threadOne的中断标志，这点非常重要。
  >
  > 所以，在主线程中调用threadOne.interrupted()方法和Thread.interrupted()方法作用是一样的，目的都是获取主线程的中断标志

## 1.8理解线程上下文切换

多线程编程中，线程个数一般大于CPU个数，而每个CPU在同一时刻只能被一个线程使用，为了多线程同时执行（宏观上并行），CPU资源采用时间片轮转的分配策略。给每个线程分配一个时间片，线程在时间片内占有CPU执行任务，，当前线程使用完时间片后，处于就绪状态并让出CPU让其他线程使用，这就是上下文切换。线程为了在下次重新获取到时间片使用CPU时，可以直到自己之前运行到哪里了，就需要在上下文切换时保存当前线程的执行现场，当再次执行时可以根据保存的执行现场信息，恢复继续执行。

线程上下文切换时机：当前线程的CPU时间片使用完处于就绪状态时；当前线程被其他线程中断。

## 1.9线程死锁

**什么是死锁：**两个或两个以上的线程在执行过程中，因为争夺资源而造成互相等待的现象，在没有外力情况下，这些线程会一直相互等待无法继续往下运行

**产生死锁的四个条件：**

1. 互斥条件。该资源在同一时刻只能被一个线程占有，其他请求者只能等待，直到占有资源的线程释放该资源。
2. 请求并持有。一个线程已经持有了至少一个资源，但又提出新的资源请求，如果新资源已经被其他线程所占有，则当前线程会被阻塞，并且不会释放已经持有的资源
3. 不可剥夺。有一个线程获取到了资源，在自己使用完之前，不能被其他线程抢占，只能在自己使用完毕后由自己释放该资源
4. 环路等待。发生死锁时，必然存在线程-资源环形链，例如，线程1持有资源A并准备获取资源B，而线程2持有资源B并准备获取资源A，形成环路

**如何避免线程死锁：**避免死锁，只需要破坏至少一个构成死锁的必要条件即可，根据操作系统（待学），只有请求并持有和环路等待条件是可以被破坏的。造成死锁的原因和申请资源的顺序有很大关系，可以在申请资源时保证申请的有序性，例如，对于申请相同资源，所有线程的资源申请顺序是相同的

## 1.10守护线程与用户线程

Java中线程分为两类，分别为守护线程（daemon线程）和用户线程（user线程）。例如，JVM启动时会调用main函数，而main函数所在的线程就是一个用户线程，JVM内部同时还有很多个守护线程，比如垃圾回收线程。

守护线程和用户线程的区别？区别之一就是当最后一个用户线程结束时，不管当前是否还有守护线程，都不影响JVM的退出，即只要还有一个用户线程没有结束，正常情况下JVM都不会退出。main线程结束后，JVM会自动启动一个叫做DestroyJavaVM的线程，该线程会等待所有用户线程结束后终止JVM进程。

代码中通过`thread.setDaemon(true);`,设置thread线程为守护线程

总结：如果希望在主线程结束后JVM也立即结束退出，那么在创建线程时可以设置为守护线程。如果希望在主线程结束后，等待子线程运行结束再让JVM退出，那将子线程设置为用户线程。



















































